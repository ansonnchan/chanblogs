---
layout: post
title: "CS vs CPEN Through the Lens of Machine Learning"
date: 2026-01-19
permalink: /cs-vs-cpen-ubc-ML/
description: "How my journey into Machine Learning blurred the line between Computer Science and Computer Engineering at UBC."
---
<hr style="margin: 40px 0; border: none; border-top: 1px solid #eee;" />

<h2>ü§ñ CS vs CPEN: My ML-Induced Identity Crisis</h2>

<p>
  Back when I was applying to UBC ‚Äî sometime around the Industrial Revolution era, apparently ‚Äî I debated heavily whether to go CS or CPEN. It felt like picking the side of the force: software Jedi or hardware Sith 
<div style="background: #fff4e5; padding: 0.8rem 1rem; border-left: 4px solid #f39c12; border-radius: 6px; margin: 0.5rem 0 1rem 0;">
  <strong>üí° Side Note:</strong> Does Gen Alpha even know what Star Wars is? Or am I too old? Soon, even kids born in the 2000s will be called ‚Äúuncs.‚Äù
</div>

</p>

<p>
  To be honest, I wasn‚Äôt completely sure I even wanted to do Machine Learning or software yet. I‚Äôd done well in STEM in high school ‚Äî especially maths and physics ‚Äî which, spoiler alert, has <em>zero correlation</em> with surviving university-level STEM. But hey, it made me feel like I had options.
</p>

<p>
  I seriously considered mechanical engineering (clearly out after the infamous APSC 101 mechanical claw project<sup><a href="#apscclaw">1</a></sup>), and civil engineering (but my parents warned me that civil engineers tend to die of hypothermia and thirst in the field‚Ä¶ thanks for the vote of confidence).
</p>

<img
  src="https://raw.githubusercontent.com/ansonnchan/chanblogs/main/assets/imgs/IMG_5209.jpg"
  alt="CPEN Co-op Postings"
  style="width: 100%; max-width: 450px; border-radius: 12px; display: block; margin: 2rem auto; border: 1px solid #ddd;"
/>
<p>
 Above is the mechanical claw our group made for the first APSC 101 group project. Shout out to my group mates for carrying me. 
</p>

<p>
  So, in the end, I went with CPEN. It was the middle ground: enough hardware to keep options open, enough software to eventually do what I wanted ‚Äî and a solid dose of ‚Äúlet‚Äôs see where this actually takes me.‚Äù
</p>

<p>
  Everyone else was giving me the usual advice: <em>CS = software, CPEN = hardware</em>. Simple. Logical. But as it turns out, it‚Äôs not that simple. And the further I got into machine learning, the more that line started to blur.
</p>

<div style="background: #f9f7f1; padding: 1.5rem; border-left: 5px solid #f39c12; border-radius: 8px; margin: 2rem 0;">
  Modern ML isn‚Äôt just ‚Äúwrite model, train model, profit.‚Äù It‚Äôs more like:
  <ul>
    <li>Why is my model bottlenecked on memory?</li>
    <li>Why does it run fine on <code>Colab</code> but crawl on real hardware?</li>
    <li>Why does moving one <code>tensor</code> suddenly spike GPU utilization to 100%?</li>
    <li>Why does that one Python typo destroy three hours of training? (RIP)</li>
  </ul>
</div>

<p>
  At this point, you stop arguing about loss functions and start arguing with the machine itself.
  And that‚Äôs where the CS vs CPEN divide starts to feel‚Ä¶ artificial.
</p>

<h3>üíª CS vs CPEN: What They Actually Teach You</h3>

<ul>
  <li>
    <strong>CS:</strong> Abstract thinking, algorithms, and ‚Äúdoes it work in theory?‚Äù You learn to build models, understand convergence, and occasionally cry over NP-complete problems.
  </li>
  <li>
    <strong>CPEN:</strong> Concrete thinking, hardware realities, and ‚Äúdoes it actually run?‚Äù You wrestle with memory hierarchies, pipelines, GPU clusters, and the terrifying world of system-level debugging.
  </li>
</ul>

<p>
  For ML, both perspectives matter. CS gives you the map; CPEN teaches you to navigate the terrain without burning your laptop.
</p>

<div style="background: #eef7f6; padding: 1.5rem; border-left: 5px solid #27ae60; border-radius: 8px; margin: 2rem 0;">
  Ironically, the deeper I got into ML, the less I cared about labels like ‚Äúsoftware‚Äù or ‚Äúhardware.‚Äù The people doing genuinely interesting ML work aren‚Äôt living at either extreme‚Äîthey‚Äôre in the uncomfortable middle: tweaking kernels, optimizing memory, and praying the server doesn‚Äôt explode.
</div>

<hr style="margin: 40px 0; border: none; border-top: 1px solid #eee;" />

<h2>üß† So‚Ä¶ Does That Mean CPEN Is ‚ÄúBetter‚Äù for ML?</h2>

<p>
  Not really. And also‚Ä¶ maybe. And yes, sometimes. (Welcome to engineering logic.)
</p>

<p>
  If your goal is ML research, applied ML, or ML-adjacent software roles,
  <strong>both degrees get you there</strong>. What changes is the <em>lens</em> you develop:
</p>

<ul>
  <li>CS trains you to think in abstractions: models, guarantees, complexity, and sometimes frustration over imaginary errors in Jupyter.</li>
  <li>CPEN forces you to confront reality: caches, pipelines, instruction sets, and the fact that ‚Äújust parallelize it‚Äù is not a solution.</li>
</ul>

<div style="background: #eef7f6; padding: 1.5rem; border-left: 5px solid #27ae60; border-radius: 8px; margin: 2rem 0;">
  Personally, that hardware exposure stopped feeling like a distraction and started feeling like context. Painful context. Occasionally soul-crushing context. But context nonetheless.
</div>

<p>
  In the end, ML made the CS vs CPEN choice feel <strong>less</strong> like a fork in the road and more like choosing which weaknesses you want to patch later ‚Äî and being okay with it.
</p>

<hr style="margin: 40px 0; border: none; border-top: 1px solid #eee;" />

<h3>üìö Glossary for the Uninitiated</h3>

<ul>
  <li><code>scikit-learn</code>: A Python library for ML; great for prototyping but hides the hardware details.</li>
  <li><code>Colab</code>: Google‚Äôs free Jupyter notebook environment; convenient but sometimes slower than your own GPU.</li>
  <li><code>tensor</code>: Multi-dimensional arrays used in ML frameworks like PyTorch and TensorFlow.</li>
  <li><code>GPU</code>: Graphics Processing Unit, the workhorse of training modern ML models quickly.</li>
  <li><code>kernel</code>: The unit of work inside a GPU; messing with it is how you accidentally overheat your server.</li>
  <li><code>pipeline</code>: The end-to-end flow of your ML model; if one step breaks, the whole thing collapses like a Jenga tower.</li>
</ul>



<p id="apscclaw" style="font-size:0.9rem; color:#555;">
  <sup>1</sup>APSC 101 project: we had to create an autonomous mechanical claw from scratch that operated with an Arduino and sensors. It was chaotic, frustrating, and glorious. Shout out Professor Pete Ostafichuk for his screencasts and Group K-9. 
</p>


